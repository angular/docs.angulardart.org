{"name":"angular-mock","qualifiedName":"angular-mock","comment":"<p>Classes and utilities for testing and prototyping in AngularDart.</p>\n<p>This is an optional library. You must import it in addition to the <a href=\"#angular/angular\">angular.dart</a> library,\nlike so:</p>\n<pre><code> import 'package:angular/angular.dart';\n import 'package:angular/mock/module.dart';\n</code></pre>","variables":{"depth":{"name":"depth","qualifiedName":"angular-mock.depth","comment":"","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]}},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"tearDownInjector":{"name":"tearDownInjector","qualifiedName":"angular-mock.tearDownInjector","comment":"<p>Call this method in your test harness tearDown method to cleanup the injector.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"setUpInjector":{"name":"setUpInjector","qualifiedName":"angular-mock.setUpInjector","comment":"<p>Call this method in your test harness setUp method to setup the injector.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"module":{"name":"module","qualifiedName":"angular-mock.module","comment":"<p>Allows the installation of new types/modules into the current test injector.</p>\n<p>This method can be called in declaration or inline in test. The method can be called\nrepeatedly, as long as <a>angular-mock.inject</a> is not called. Invocation of <a>angular-mock.inject</a> creates the injector and\nhence no more calls to <a>angular-mock.module</a> can be made.</p>\n<pre><code>setUp(module((Module model) {\n  module.type(Foo);\n});\n\ntest('foo', () {\n  module((Module module) {\n    module.type(Foo);\n  });\n});\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"fnOrModule":{"name":"fnOrModule","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"inject":{"name":"inject","qualifiedName":"angular-mock.inject","comment":"<p>Allows the injection of instances into a test. See <a>angular-mock.module</a> on how to install new\ntypes into injector.</p>\n<p>NOTE: Calling inject creates an injector, which prevents any more calls to <a>angular-mock.module</a>.</p>\n<p>Typical usage:</p>\n<pre><code>test('wrap whole test', inject((TestBed tb) {\n  tb.compile(...);\n});\n\ntest('wrap part of a test', () {\n  module((Module module) {\n    module.type(Foo);\n  });\n  inject((TestBed tb) {\n    tb.compile(...);\n  });\n});\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"sync":{"name":"sync","qualifiedName":"angular-mock.sync","comment":"<p>Enforces synchronous code.  Any calls to scheduleMicrotask inside of 'sync'\nwill throw an exception.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"async":{"name":"async","qualifiedName":"angular-mock.async","comment":"<p>Captures all scheduleMicrotask calls inside of a function.</p>\n<p>Typically used within a test:</p>\n<pre><code>it('should be async', async(() {\n  ...\n}));\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"noMoreAsync":{"name":"noMoreAsync","qualifiedName":"angular-mock.noMoreAsync","comment":"<p>Causes scheduleMicrotask calls to throw exceptions.</p>\n<p>This function is useful while debugging async tests: the exception\nis thrown from the scheduleMicrotask call-site instead later in the test.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{},"annotations":[]},"clockTick":{"name":"clockTick","qualifiedName":"angular-mock.clockTick","comment":"<p>Simulates a clock tick by running any scheduled timers. Can only be used\nin <a>angular-mock.async</a> tests.Clock tick will call <a>angular-mock.microLeap</a> to process the microtask\nqueue before each timer callback.</p>\n<p>Note: microtasks scheduled form the last timer are not going to be processed.</p>\n<p>Example:</p>\n<pre><code>it('should run queued timer after sufficient clock ticks', async(() {\n  bool timerRan = false;\n  new Timer(new Duration(milliseconds: 10), () =&gt; timerRan = true);\n\n  clockTick(milliseconds: 9);\n  expect(timerRan).toBeFalsy();\n  clockTick(milliseconds: 1);\n  expect(timerRan).toBeTruthy();\n}));\n\nit('should run periodic timer', async(() {\n  int timerRan = 0;\n  new Timer.periodic(new Duration(milliseconds: 10), (_) =&gt; timerRan++);\n\n  clockTick(milliseconds: 9);\n  expect(timerRan).toBe(0);\n  clockTick(milliseconds: 1);\n  expect(timerRan).toBe(1);\n  clockTick(milliseconds: 30);\n  expect(timerRan).toBe(4);\n}));\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"days":{"name":"days","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"hours":{"name":"hours","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"minutes":{"name":"minutes","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"seconds":{"name":"seconds","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"milliseconds":{"name":"milliseconds","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"microseconds":{"name":"microseconds","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]}},"annotations":[]},"isAsyncQueueEmpty":{"name":"isAsyncQueueEmpty","qualifiedName":"angular-mock.isAsyncQueueEmpty","comment":"<p>Returns whether the async queue is empty.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{},"annotations":[]},"microLeap":{"name":"microLeap","qualifiedName":"angular-mock.microLeap","comment":"<p>Runs any queued up async calls and any async calls queued with\nrunning microLeap. Example:</p>\n<pre><code>it('should run async code', async(() {\n  var thenRan = false;\n  new Future.value('s').then((_) { thenRan = true; });\n  expect(thenRan).toBe(false);\n  microLeap();\n  expect(thenRan).toBe(true);\n}));\n\nit('should run chained thens', async(() {\n  var log = [];\n  new Future.value('s')\n    .then((_) { log.add('firstThen'); })\n    .then((_) { log.add('2ndThen'); });\n  expect(log.join(' ')).toEqual('');\n  microLeap();\n  expect(log.join(' ')).toEqual('firstThen 2ndThen');\n}));\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{},"annotations":[]},"STRINGIFY":{"name":"STRINGIFY","qualifiedName":"angular-mock.STRINGIFY","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"obj":{"name":"obj","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"dump":{"name":"dump","qualifiedName":"angular-mock.dump","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"p1":{"name":"p1","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"p2":{"name":"p2","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"p3":{"name":"p3","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"p4":{"name":"p4","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"p5":{"name":"p5","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"p6":{"name":"p6","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"p7":{"name":"p7","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"p8":{"name":"p8","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"p9":{"name":"p9","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"p10":{"name":"p10","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"MARK":{"name":"MARK","qualifiedName":"angular-mock.MARK","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"LEAVE":{"name":"LEAVE","qualifiedName":"angular-mock.LEAVE","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"ENTER":{"name":"ENTER","qualifiedName":"angular-mock.ENTER","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"MockProgressEvent","qualifiedName":"angular-mock.MockProgressEvent"},{"name":"MockHttpRequest","qualifiedName":"angular-mock.MockHttpRequest","preview":"<p>Mock implementation of the <a>angular-mock.HttpRequest</a> object returned from the HttpBackend.</p>"},{"name":"MockHttpBackend","qualifiedName":"angular-mock.MockHttpBackend","preview":"<p>A mock implementation of <a>angular-mock.HttpBackend</a>, used in tests.</p>"},{"name":"MockHttpExpectation","qualifiedName":"angular-mock.MockHttpExpectation","preview":"<p>An internal class used by <a>angular-mock.MockHttpBackend</a>.</p>"},{"name":"FunctionComposition","qualifiedName":"angular-mock.FunctionComposition"},{"name":"MockDocument","qualifiedName":"angular-mock.MockDocument"},{"name":"MockLocation","qualifiedName":"angular-mock.MockLocation"},{"name":"MockHistory","qualifiedName":"angular-mock.MockHistory"},{"name":"MockWindow","qualifiedName":"angular-mock.MockWindow"},{"name":"TestBed","qualifiedName":"angular-mock.TestBed","preview":"<p>Class which simplifies bootstraping of angular for unit tests.</p>"},{"name":"Probe","qualifiedName":"angular-mock.Probe"},{"name":"Logger","qualifiedName":"angular-mock.Logger","preview":"<p>A convenient way to verify that a set of operations executed in a specific\norder. Simply inject the Logger into each operation and call:</p>"},{"name":"LogAttrDirective","qualifiedName":"angular-mock.LogAttrDirective","preview":"<p>A convenient way to assert the order in which the DOM elements are processed.</p>"},{"name":"LoggingExceptionHandler","qualifiedName":"angular-mock.LoggingExceptionHandler","preview":"<p>Mock implementation of <a>angular-mock.ExceptionHandler</a> that logs all exceptions for\nlater processing.</p>"},{"name":"ExceptionWithStack","qualifiedName":"angular-mock.ExceptionWithStack"},{"name":"RethrowExceptionHandler","qualifiedName":"angular-mock.RethrowExceptionHandler","preview":"<p>Mock implementation of <a>angular-mock.ExceptionHandler</a> that rethrows exceptions.</p>"},{"name":"AngularMockModule","qualifiedName":"angular-mock.AngularMockModule","preview":"<p>Use in addition to <a>angular-app.AngularModule</a> in your tests.</p>"}],"typedef":{},"error":[]},"packageName":"","packageIntro":null}
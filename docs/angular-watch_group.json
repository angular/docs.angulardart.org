{"name":"angular-watch_group","qualifiedName":"angular-watch_group","comment":"","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{}},"classes":{"class":[{"name":"PrototypeMap","qualifiedName":"angular-watch_group.PrototypeMap"},{"name":"CollectionAST","qualifiedName":"angular-watch_group.CollectionAST"},{"name":"MethodAST","qualifiedName":"angular-watch_group.MethodAST","preview":"<p>SYNTAX: lhs.method(arg0, arg1, ...)</p>"},{"name":"PureFunctionAST","qualifiedName":"angular-watch_group.PureFunctionAST","preview":"<p>SYNTAX: fn(arg0, arg1, ...)</p>"},{"name":"FieldReadAST","qualifiedName":"angular-watch_group.FieldReadAST","preview":"<p>SYNTAX: lhs.name.</p>"},{"name":"ConstantAST","qualifiedName":"angular-watch_group.ConstantAST","preview":"<p>SYNTAX: <em>context</em></p>"},{"name":"ContextReferenceAST","qualifiedName":"angular-watch_group.ContextReferenceAST","preview":"<p>SYNTAX: <em>context</em></p>"},{"name":"AST","qualifiedName":"angular-watch_group.AST","preview":"<p>RULES:\n - ASTs are reusable. Don't store scope/instance refs there\n - Parent knows about children, not the other way around.</p>"},{"name":"Watch","qualifiedName":"angular-watch_group.Watch","preview":"<p><a>angular-watch_group.Watch</a> corresponds to an individual watch registration on the watchGrp.</p>"},{"name":"RootWatchGroup","qualifiedName":"angular-watch_group.RootWatchGroup","preview":"<p><a>angular-watch_group.RootWatchGroup</a></p>"},{"name":"WatchGroup","qualifiedName":"angular-watch_group.WatchGroup","preview":"<p><a>angular-watch_group.WatchGroup</a> is a logical grouping of a set of watches. <a>angular-watch_group.WatchGroup</a>s are\norganized into a hierarchical tree parent-children configuration.\n<a>angular-watch_group.WatchGroup</a> builds upon <a>change_detection.ChangeDetector</a> and adds expression (field chains\nas in <code>a.b.c</code>) support as well as support function/closure/method (function\ninvocation as in <code>a.b()</code>) watching.</p>"},{"name":"FunctionApply","qualifiedName":"angular-watch_group.FunctionApply","preview":"<p>Extend this class if you wish to pretend to be a function, but you don't know\nnumber of arguments with which the function will get called.</p>"}],"typedef":{"ChangeLog":{"name":"ChangeLog","qualifiedName":"angular-watch_group.ChangeLog","comment":"","return":"dynamic","parameters":{"expression":{"name":"expression","optional":"false","named":"false","default":"false","type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"current":{"name":"current","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"previous":{"name":"previous","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[],"generics":{}},"ReactionFn":{"name":"ReactionFn","qualifiedName":"angular-watch_group.ReactionFn","comment":"","return":"dynamic","parameters":{"value":{"name":"value","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"previousValue":{"name":"previousValue","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[],"generics":{}}},"error":[]},"packageName":"","packageIntro":""}
{"name":"OrderBy","qualifiedName":"angular/angular.OrderBy","comment":"<p>Orders the the elements of a list using a predicate.</p>\n<h1>Usage</h1>\n<pre><code> expression | orderBy:predicate[:true]\n</code></pre>\n<p>The input to orderBy must be an <a>angular/dart-core.Iterable</a> object. The predicate may be specified as:</p><ul><li><strong>a string</strong>: a string containing an expression, such as \"user.lastName\", used to order the list.</li><li>\n<p><strong>a custom callable expression</strong>: an expression that will be called to transform the element\n  before a sort.</p></li><li>\n<p><strong>a list</strong>: the list may consist of either strings or callable expressions.  A list expression\n  indicates a list of fallback expressions to use when a comparision results in the items\n  being equal.</p></li></ul>\n<p>If the expression is explicitly empty(<code>orderBy:''</code>), the elements are sorted in\nascending order, using the default comparator, <code>+</code>.</p>\n<p>A string expression in the predicate can be prefixed to indicate sort order:</p><ul><li><code>+</code>: sort the elements in ascending order. This is the default.</li><li><code>-</code>: sort the elements in descending order.</li></ul>\n<p>Alternately, by appending <code>true</code>, you can set \"descending order\" to true, which has the same effect as the <code>-</code>\nprefix.</p>\n<h1>Examples</h1>\n<h2>Example 1: Simple array and single/empty expression.</h2>\n<p>Assume that you have an array on scope called <code>colors</code> and that it has a list\nof these strings â€“ <code>['red', 'blue', 'green']</code>.  You might sort these in\nascending order this way:</p>\n<pre><code>Colors: &lt;ul&gt;\n  &lt;li ng-repeat=\"color in colors | orderBy:''\"&gt;{{color}}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>That would result in:</p>\n<pre><code>&lt;ul&gt;\n  &lt;li&gt;blue&lt;/li&gt;\n  &lt;li&gt;green&lt;/li&gt;\n  &lt;li&gt;red&lt;/li&gt;\n&lt;ul&gt;\n</code></pre>\n<p>The empty string expression, <code>''</code>, here signifies sorting in ascending order\nusing the default comparator.  Using <code>'+'</code> would also work, as the <code>+</code> prefix\nis implied.</p>\n<p>To sort in descending order, you would use the <code>'-'</code> prefix.</p>\n<pre><code>Colors: &lt;ul&gt;\n  &lt;li ng-repeat=\"color in colors | orderBy:'-'\"&gt;{{color}}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>For this simple example, you could have also provided <code>true</code> as the addition\noptional parameter which requests a reverse order sort to get the same\nresult.</p>\n<pre><code>&lt;!-- Same result (descending order) as previous snippet. --&gt;\nColors: &lt;ul&gt;\n  &lt;li ng-repeat=\"color in colors | orderBy:'':true\"&gt;{{color}}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h2>Example 2: Complex objects, single expression.</h2>\n<p>You may provide a more complex expression to sort non-primitive values or\nif you want to sort on a decorated/transformed value.</p>\n<p>e.g. Support you have a list <code>users</code> that looks like this:</p>\n<pre><code>authors = [\n  {firstName: 'Emily',   lastName: 'Bronte'},\n  {firstName: 'Mark',    lastName: 'Twain'},\n  {firstName: 'Jeffrey', lastName: 'Archer'},\n  {firstName: 'Isaac',   lastName: 'Asimov'},\n  {firstName: 'Oscar',   lastName: 'Wilde'},\n];\n</code></pre>\n<p>If you want to list the authors sorted by <code>lastName</code>, you would use</p>\n<pre><code>&lt;li ng-repeat=\"author in authors | orderBy:'lastName'\"&gt;\n  {{author.lastName}}, {{author.firstName}}\n&lt;/li&gt;\n</code></pre>\n<p>The string expression, <code>'lastName'</code>, indicates that the sort should be on the\n<code>lastName</code> property of each item.</p>\n<p>Using the lesson from the previous example, you may sort in reverse order of\nlastName using either of the two methods.</p>\n<pre><code>&lt;!-- reverse order of last names --&gt;\n&lt;li ng-repeat=\"author in authors | orderBy:'-lastName'\"&gt;\n&lt;!-- also does the same thing --&gt;\n&lt;li ng-repeat=\"author in authors | orderBy:'lastName':true\"&gt;\n</code></pre>\n<p>Note that, while we only discussed string expressions, such as <code>\"lastName\"</code>\nor the empty string, you can also directly provide a custom callable that\nwill be called to transform the element before a sort.</p>\n<pre><code>&lt;li ng-repeat=\"author in authors | orderBy:getAuthorId\"&gt;\n</code></pre>\n<p>In the previous snippet, <code>getAuthorId</code> would evaluate to a callable when\nevaluated on the <a href=\"#angular-core.Scope\">Scope</a> of the <code>&lt;li&gt;</code> element.  That callable is called once\nfor each element in the list (i.e. each author object) and the sort order is\ndetermined by the sort order of the value mapped by the callable.</p>\n<h2>Example 3: List expressions</h2>\n<p>Both a string expression and the callable expression are simple versions of\nthe more general list expression.  You may pass a list as the orderBy\nexpression and this list may consist of either of the string or callable\nexpressions you saw in the previous examples.  A list expression indicates\na list of fallback expressions to use when a comparision results in the items\nbeing equal.</p>\n<p>For example, one might want to sort the authors list, first by last name and\nthen by first name when the last names are equal.  You would do that like\nthis:</p>\n<pre><code>&lt;li ng-repeat=\"author in authors | orderBy:['lastName', 'firstName']\"&gt;\n</code></pre>\n<p>The items in such a list may either be string expressions or callables.  The\nlist itself might be provided as an expression that is looked up on the scope\nchain.</p>","isAbstract":false,"superclass":"dart-core.Object","implements":["dart-core.Function"],"subclass":[],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{},"constructors":{"":{"name":"","qualifiedName":"angular/angular.OrderBy.OrderBy-","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"_parser":{"name":"_parser","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular.Parser","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{"call":{"name":"call","qualifiedName":"angular/angular.OrderBy.call","comment":"<p>Order a list by expression.</p><ul><li><code>expression</code>: String/Function or Array of String/Function.</li><li><code>descending</code>: When specified, use descending order. (The default is ascending order.)</li></ul>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.List","inner":[]}],"parameters":{"items":{"name":"items","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"expression":{"name":"expression","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"descending":{"name":"descending","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"angular/angular.OrderBy.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>angular/angular.OrderBy.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"angular/angular.OrderBy.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"angular/angular.OrderBy.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>angular/angular.OrderBy.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>angular/angular.OrderBy.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"angular/angular.OrderBy.noSuchMethod","comment":"<p><a>angular/angular.OrderBy.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>angular/angular.OrderBy.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>angular/angular.OrderBy.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>angular/angular.OrderBy.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"angular/angular.OrderBy.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[{"name":"angular/angular.Formatter","parameters":["name:'orderBy'"]}],"generics":{}}
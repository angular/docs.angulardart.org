{"name":"NgRepeat","qualifiedName":"angular/angular-directive.NgRepeat","comment":"<p>The <code>ngRepeat</code> directive instantiates a template once per item from a\ncollection. Each template instance gets its own scope, where the given loop\nvariable is set to the current collection item, and <code>$index</code> is set to the\nitem index or key.</p>\n<p>Special properties are exposed on the local scope of each template instance,\nincluding:</p><ul><li>\n<p><code>$index</code> (<code>num</code>) the iterator offset of the repeated element\n (0..length-1)</p></li><li>\n<p><code>$first</code>  (<code>bool</code>) whether the repeated element is first in the\n iterator.</p></li><li>\n<p><code>$middle</code> (<code>bool</code>) whether the repeated element is between the first\n and last in the iterator.</p></li><li><code>$last</code> (<code>bool</code>) whether the repeated element is last in the iterator.</li><li><code>$even</code> (<code>bool</code>) whether the iterator position <code>$index</code> is even.</li><li><code>$odd</code> (<code>bool</code>) whether the iterator position <code>$index</code> is odd.</li></ul>\n<p>repeat_expression ngRepeat The expression indicating how to enumerate a\ncollection. These formats are currently supported:</p><ul><li>\n<p><code>variable in expression</code> – where variable is the user defined loop\n  variable and <code>expression</code> is a scope expression giving the collection to\n  enumerate.</p>\n<p>For example: <code>album in artist.albums</code>.</p></li><li>\n<p><code>variable in expression track by tracking_expression</code> – You can also\n  provide an optional tracking function which can be used to associate the\n  objects in the collection with the DOM elements. If no tracking function is\n  specified the ng-repeat associates elements by identity in the collection.\n  It is an error to have more than one tracking function to resolve to the\n  same key. (This would mean that two distinct objects are mapped to the same\n  DOM element, which is not possible.)  Formatters should be applied to the\n  expression, before specifying a tracking expression.</p>\n<p>For example: <code>item in items</code> is equivalent to <code>item in items track by\n$id(item)</code>. This implies that the DOM elements will be associated by item\nidentity in the array.</p>\n<p>For example: <code>item in items track by $id(item)</code>. A built in <code>$id()</code>\nfunction can be used to assign a unique <code>$$hashKey</code> property to each item\nin the array. This property is then used as a key to associated DOM\nelements with the corresponding item in the array by identity. Moving the\nsame object in array would move the DOM element in the same way in the\nDOM.</p>\n<p>For example: <code>item in items track by item.id</code> is a typical pattern when\nthe items come from the database. In this case the object identity does\nnot matter. Two objects are considered equivalent as long as their <code>id</code>\nproperty is same.</p>\n<p>For example: <code>item in items | filter:searchText track by item.id</code> is a\npattern that might be used to apply a formatter to items in conjunction with\na tracking expression.</p></li></ul>\n<h1>Example:</h1>\n<pre><code>&lt;ul&gt;\n  &lt;li ng-repeat=\"item in ['foo', 'bar', 'baz']\"&gt;{{item}}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>","isAbstract":false,"superclass":"dart-core.Object","implements":[],"subclass":[],"variables":{"formatters":{"name":"formatters","qualifiedName":"angular/angular.NgRepeat.formatters","comment":"","final":true,"static":false,"constant":false,"type":[{"outer":"angular/angular.FormatterMap","inner":[]}],"annotations":[]}},"inheritedVariables":{},"methods":{"setters":{"expression=":{"name":"expression=","qualifiedName":"angular/angular-directive.NgRepeat.expression=","comment":"","commentFrom":"angular-directive.NgRepeat.expression=","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"getters":{},"constructors":{"":{"name":"","qualifiedName":"angular/angular-directive.NgRepeat.NgRepeat-","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"_viewPort":{"name":"_viewPort","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core-dom_internal.ViewPort","inner":[]}],"value":null,"annotations":[]},"_boundViewFactory":{"name":"_boundViewFactory","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core-dom_internal.BoundViewFactory","inner":[]}],"value":null,"annotations":[]},"_scope":{"name":"_scope","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core_internal.Scope","inner":[]}],"value":null,"annotations":[]},"_parser":{"name":"_parser","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core-parser.Parser","inner":[]}],"value":null,"annotations":[]},"formatters":{"name":"formatters","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core_internal-formatter_map.FormatterMap","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"angular/angular-directive.NgRepeat.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>angular/angular-directive.NgRepeat.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"angular/angular-directive.NgRepeat.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"angular/angular-directive.NgRepeat.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>angular/angular-directive.NgRepeat.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>angular/angular-directive.NgRepeat.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"angular/angular-directive.NgRepeat.noSuchMethod","comment":"<p><a>angular/angular-directive.NgRepeat.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>angular/angular-directive.NgRepeat.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>angular/angular-directive.NgRepeat.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>angular/angular-directive.NgRepeat.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"angular/angular-directive.NgRepeat.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[{"name":"angular/angular-core-annotation_src.Decorator","parameters":["children:Directive.TRANSCLUDE_CHILDREN","selector:'[ng-repeat]'","map:const{'.':'@expression'","}"]}],"generics":{}}
{"name":"Scope","qualifiedName":"angular/angular-core.Scope","comment":"<p><a>angular/angular-core.Scope</a> represents a collection of <a>angular/angular-core.Scope.watch</a>es, observers, and a <a>angular/angular-core.Scope.context</a> for the watchers,\nobservers and <a>angular/angular-core.Scope.eval</a>uations. Scopes structure loosely mimics the DOM structure. Scopes and\nViews are bound to each other. As scopes are created and destroyed by ViewFactory they are\nresponsible for change detection, change processing and memory management.</p>\n<h2>Understanding the Scope Digest Life Cycle</h2>\n<p>The following diagram illustrates the order of events in a Scope digest\nloop:\n<a href=\"https://docs.google.com/drawings/d/1ELigkn4P3jeSUqvUErrp38vd5Qk7uYFcSA2ACKQn_rI/pub?w=480&amp;h=360\"><img alt=\"Scope Digest Loop Illustration\" src=\"https://docs.google.com/drawings/d/1ELigkn4P3jeSUqvUErrp38vd5Qk7uYFcSA2ACKQn_rI/pub?w=480&amp;h=360\"></img></a></p>\n<p>Angular updates the template UI by executing <code>apply()</code> at the end of a VM turn. The\n<code>apply</code> step is then broken down into digest and flush cycles. Digest loops are used for\ninter-model communication, the flush cycle is used for UI rendering only.</p>\n<p> <strong>Digest cycle</strong></p>\n<p> At the beginning of the watch, Angular processes the asyncQueue (used by Futures to execute\n microtasks), then keeps looping until there are no more changes detected in the digest loop.\n Changes are delivered to the WatchReaction Functions.</p>\n<p> <strong>Flush cycle</strong></p>\n<p> Flush runs only once per digest loop, and is used to render the template UI. It is mostly used\n by interpolation syntax in <code>{{}}</code> templates. In dev mode, we run flush a second time,\n to assert that flushes have no side effects.</p>\n<p> We also process the DOM read/write queue at this point.</p>\n<p> <strong>Use of Watches</strong></p>\n<p> Watches in digest are permitted to have side effects, watches in flush are not allowed to have\n side effects.</p>","isAbstract":false,"superclass":"dart-core.Object","implements":[],"subclass":["angular/angular-core.RootScope"],"variables":{"context":{"name":"context","qualifiedName":"angular/angular-core.Scope.context","comment":"<p>The default execution context for <a>angular/angular-core.RootScope.watch</a>es observeers, and <a>angular/angular-core.RootScope.eval</a>uation.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"id":{"name":"id","qualifiedName":"angular/angular-core.Scope.id","comment":"","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"rootScope":{"name":"rootScope","qualifiedName":"angular/angular-core.Scope.rootScope","comment":"<p>The <a>angular/angular-core.RootScope</a> of the application.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"angular/angular-core.RootScope","inner":[]}],"annotations":[]}},"inheritedVariables":{},"methods":{"setters":{},"getters":{"hasOwnStreams":{"name":"hasOwnStreams","qualifiedName":"angular/angular-core.Scope.hasOwnStreams","comment":"<p>Do not use. Exposes internal state for testing.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isAttached":{"name":"isAttached","qualifiedName":"angular/angular-core.Scope.isAttached","comment":"<p>true when the scope is still attached to the <a>angular/angular-core.RootScope</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isDestroyed":{"name":"isDestroyed","qualifiedName":"angular/angular-core.Scope.isDestroyed","comment":"<p>Return <code>true</code> if the scope has been destroyed. Once scope is destroyed\nNo operations are allowed on it.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"parentScope":{"name":"parentScope","qualifiedName":"angular/angular-core.Scope.parentScope","comment":"","commentFrom":"angular-core.Scope.parentScope","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.Scope","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"angular/angular-core.Scope.Scope-","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"context":{"name":"context","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]},"rootScope":{"name":"rootScope","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.RootScope","inner":[]}],"value":null,"annotations":[]},"_parentScope":{"name":"_parentScope","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.Scope","inner":[]}],"value":null,"annotations":[]},"_readWriteGroup":{"name":"_readWriteGroup","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.WatchGroup","inner":[]}],"value":null,"annotations":[]},"_readOnlyGroup":{"name":"_readOnlyGroup","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.WatchGroup","inner":[]}],"value":null,"annotations":[]},"id":{"name":"id","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"_stats":{"name":"_stats","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.ScopeStats","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{"apply":{"name":"apply","qualifiedName":"angular/angular-core.Scope.apply","comment":"<p>Triggers a digest cycle. It accepts an optional <a>angular/angular-core.Scope.apply.expression</a> to evaluate before the digest\noperation. The result of that expression will be returned afterwards.</p>\n<p><a>angular/angular-core.Scope.apply</a> should only be called from the within unit tests to simulate the life cycle of a scope.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"expression":{"name":"expression","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"locals":{"name":"locals","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"broadcast":{"name":"broadcast","qualifiedName":"angular/angular-core.Scope.broadcast","comment":"<p>Triggers a <a>angular/angular-core.ScopeEvent</a> referenced by the <a>angular/angular-core.Scope.broadcast.name</a> parameters downards towards the leaf nodes of\nthe scope tree. If intercepted, by a child scope containing a matching scope event listener\n(which is registered via the <a>angular/angular-core.Scope.on</a> method), then the event listener callback function will be\nexecuted.</p>\n<p>The triggered <a>angular/angular-core.ScopeEvent</a> references the <a>angular/angular-core.Scope.broadcast.data</a> so that they can be retrieve in the listener.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.ScopeEvent","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"data":{"name":"data","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"createChild":{"name":"createChild","qualifiedName":"angular/angular-core.Scope.createChild","comment":"<p>Creates a child <a>angular/angular-core.Scope</a> with the given <a>angular/angular-core.Scope.createChild.childContext</a></p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.Scope","inner":[]}],"parameters":{"childContext":{"name":"childContext","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"createProtoChild":{"name":"createProtoChild","qualifiedName":"angular/angular-core.Scope.createProtoChild","comment":"<p>Creates a child <a>angular/angular-core.Scope</a> that is prototypal with respect to current scope.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.Scope","inner":[]}],"parameters":{},"annotations":[]},"destroy":{"name":"destroy","qualifiedName":"angular/angular-core.Scope.destroy","comment":"<p>Removes the current scope (and all of its children) from the parent scope. Removal implies\nthat calls to digest will no longer propagate to the current scope nor its children.</p>\n<p>The <code>destroy()</code> operation is usually used within directives that perform transclusion on\nmultiple child elements (like ngRepeat) which create multiple child scopes.</p>\n<p>Just before a scope is destroyed, a <a>angular/angular-core_internal.ScopeEvent.DESTROY</a> event is broadcasted from this scope.\nThis allows for child scopes (such as shared directives) to perform any necessary cleanup\nbefore the scope is removed from the application.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"domRead":{"name":"domRead","qualifiedName":"angular/angular-core.Scope.domRead","comment":"<p>Internal. Use View.domRead instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}}},"annotations":[]},"domWrite":{"name":"domWrite","qualifiedName":"angular/angular-core.Scope.domWrite","comment":"<p>Internal. Use View.domWrite instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}}},"annotations":[]},"emit":{"name":"emit","qualifiedName":"angular/angular-core.Scope.emit","comment":"<p>Triggers a <a>angular/angular-core.ScopeEvent</a> referenced by the <a>angular/angular-core.Scope.emit.name</a> parameters upwards towards the root of the\nscope tree. If intercepted, by a parent scope containing a matching scope event listener\n(which is registered via the <a>angular/angular-core.Scope.on</a> method), then the event listener callback function will be\nexecuted.</p>\n<p>The triggered <a>angular/angular-core.ScopeEvent</a> references the <a>angular/angular-core.Scope.emit.data</a> so that they can be retrieve in the listener.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.ScopeEvent","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"data":{"name":"data","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"eval":{"name":"eval","qualifiedName":"angular/angular-core.Scope.eval","comment":"<p>Evaluates the <a>angular/angular-core.Scope.eval.expression</a> against the current scope and returns the result. Note that, the\nexpression data is relative to the data within the scope. Therefore an expression such as\n<code>a + b</code> will deference variables <code>a</code> and <code>b</code> and return a result so long as <code>a</code> and <code>b</code>\nexist on the scope.</p><ul><li>\n<p><a>angular/angular-core.Scope.eval.expression</a>: The expression that will be evaluated. This can be either a Function or a\n  String.</p></li><li>\n<p><a>angular/angular-core.Scope.eval.locals</a>: A Map that will override any matching context members for the purposes of the\n  evaluation.</p></li></ul>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"expression":{"name":"expression","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"locals":{"name":"locals","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"on":{"name":"on","qualifiedName":"angular/angular-core.Scope.on","comment":"<p>Registers a scope-based event listener to intercept events triggered by <a>angular/angular-core.Scope.broadcast</a> (from any\nparent scopes) or <a>angular/angular-core.Scope.emit</a> (from child scopes) that match the given event <a>angular/angular-core.Scope.on.name</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular-core_internal.ScopeStream","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"watch":{"name":"watch","qualifiedName":"angular/angular-core.Scope.watch","comment":"<p>Use <a>angular/angular-core.Scope.watch</a> to set up change detection on an expression.</p><ul><li>\n<p><a>angular/angular-core.Scope.watch.expression</a>: The expression to watch for changes.\n  Expressions may use a special notation in addition to what is supported by the parser.\n  In particular:</p></li><li>\n<p>If an expression begins with '::', it is unwatched as soon as it evaluates to a non-null\n  value.</p></li><li>\n<p>If an expression begins with ':', it only calls the <a>angular/angular-core.Scope.watch.reactionFn</a> if the expression\n  evaluates to a non-null value.</p></li><li>\n<p><a>angular/angular-core.Scope.watch.reactionFn</a>: The reaction function to execute when a change is detected in the watched\n  expression.</p></li><li>\n<p><a>angular/angular-core.Scope.watch.formatters</a>: If the watched expression contains formatters,\n  this map specifies the set of formatters that are used by the expression.</p></li><li>\n<p><a>angular/angular-core.Scope.watch.canChangeModel</a>: Specifies whether the <a>angular/angular-core.Scope.watch.reactionFn</a> changes the model. Reaction\n  functions that change the model are processed as part of the digest cycle. Otherwise,\n  they are processed as part of the flush cycle.</p></li><li>\n<p><a>angular/angular-core.Scope.watch.collection</a>: If <code>true</code>, then the expression points to a collection (a list or a map),\n  and the collection should be shallow watched. If <code>false</code> then the expression is watched\n  by reference. When watching a collection, the reaction function receives a\n  <a>angular/change_detection.CollectionChangeItem</a> that lists all the changes.</p></li></ul>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.Watch","inner":[]}],"parameters":{"expression":{"name":"expression","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"reactionFn":{"name":"reactionFn","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.ReactionFn","inner":[]}],"value":null,"annotations":[]},"context":{"name":"context","optional":true,"named":true,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"formatters":{"name":"formatters","optional":true,"named":true,"default":false,"type":[{"outer":"angular/angular-core.FormatterMap","inner":[]}],"value":null,"annotations":[]},"canChangeModel":{"name":"canChangeModel","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]},"collection":{"name":"collection","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"watchAST":{"name":"watchAST","qualifiedName":"angular/angular-core.Scope.watchAST","comment":"<p>Use <a>angular/angular-core.Scope.watch</a> to set up change detection on an pre-parsed AST.</p><ul><li><a>angular/angular-core.Scope.watchAST.ast</a>: The pre-parsed AST.</li><li><a>angular/angular-core.Scope.watchAST.reactionFn</a>: The function executed when a change is detected.</li><li><a>angular/angular-core.Scope.watchAST.canChangeModel</a>: Whether or not the <a>angular/angular-core.Scope.watchAST.reactionFn</a> can change the model.</li></ul>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.Watch","inner":[]}],"parameters":{"ast":{"name":"ast","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.AST","inner":[]}],"value":null,"annotations":[]},"reactionFn":{"name":"reactionFn","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.ReactionFn","inner":[]}],"value":null,"annotations":[]},"canChangeModel":{"name":"canChangeModel","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"angular/angular-core.Scope.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>angular/angular-core.Scope.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"angular/angular-core.Scope.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"angular/angular-core.Scope.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>angular/angular-core.Scope.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>angular/angular-core.Scope.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"angular/angular-core.Scope.noSuchMethod","comment":"<p><a>angular/angular-core.Scope.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>angular/angular-core.Scope.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>angular/angular-core.Scope.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>angular/angular-core.Scope.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"angular/angular-core.Scope.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}
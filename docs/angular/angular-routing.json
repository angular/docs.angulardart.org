{"name":"angular-routing","qualifiedName":"angular/angular-routing","comment":"<p>Route configuration for single-page applications.</p>\n<p>The routing library makes it easier to build large single-page\napplications. The library lets you map the browser address bar to semantic\nstructure of your application and keeps them in sync.</p>\n<p>Angular uses the route_hierarchical package to define application routes\nand to provide custom tools to make it easier to use routing with Angular\ntemplates.</p>\n<p>Let's consider a simple recipe book application. The application might have\nthe following pages:</p><ul><li>recipes list/search</li><li>add new recipe</li><li>view recipe</li><li>edit recipe</li></ul>\n<p>Each of those pages can be represented by an address:</p><ul><li><code>/recipes</code></li><li><code>/addRecipe</code></li><li><code>/recipe/:recipeId/view</code></li><li><code>/recipe/:recipeId/edit</code></li></ul>\n<p>Let's try to define those routes in Angular. To get started we need to\nprovide an implementation of <a>angular/angular-routing.RouteInitializerFn</a> function.</p>\n<pre><code> void initRoutes(Router router, RouteViewFactory view) {\n   // define routes here.\n }\n\n var module = new Module()\n     ..bind(RouteInitializerFn, toValue: initRoutes);\n</code></pre>\n<p> Let's see how we could define our routes using the routing framework:</p>\n<pre><code> void initRoutes(Router router, RouteViewFactory views) {\n   views.configure({\n       'recipes': ngRoute(path: '/recipes', view: 'recipes.html'),\n       'addRecipe': ngRoute(path: '/addRecipe', view: 'addRecipe.html'),\n       'viewRecipe': ngRoute(path: '/recipe/:recipeId/view', view: 'viewRecipe.html'),\n       'editRecipe': ngRoute(path: '/recipe/:recipeId/edit', view: 'editRecipe.html)\n   });\n }\n</code></pre>\n<p> We defined 4 routes and for each route we set views (templates) to be\n displayed when that route is \"entered\". For example, when the browser URL\n is set to <code>/recipes</code>, the <code>recipes.html</code> template will be displayed.</p>\n<p> You have to tell Angular where to load views by putting <code>&lt;ng-view&gt;</code> tag in\n you template.</p>\n<p> Notice that <code>viewRecipe</code> and <code>editRecipe</code> route paths have <code>recipeId</code>\n parameter in them. We need to be able to get hold of that parameter in\n order to know which recipe to load. Let's consider the following\n <code>viewRecipe.html</code>.</p>\n<pre><code> &lt;view-recipe&gt;&lt;/view-recipe&gt;\n</code></pre>\n<p> The template contains a custom <code>view-recipe</code> component that handles\n displaying the recipe. Now, our <code>view-recipe</code> can inject <a>angular/angular-routing.RouteProvider</a>\n to get hold of the route and its parameters. It might look like this:</p>\n<pre><code> @Component(...)\n class ViewRecipe {\n   ViewRecipe(RouteProvider routeProvider) {\n     String recipeId = routeProvider.parameters['recipeId'];\n     _loadRecipe(recipeId);\n   }\n }\n</code></pre>\n<p> <a>angular/angular-routing.RouteProvider</a> and <a>angular/route-client.Route</a> can be used to control navigation, specifically,\n leaving of the route. For example, let's consider \"edit recipe\" component:</p>\n<pre><code> @Component(...)\n class EditRecipe implements DetachAware {\n   RouteHandle route;\n   EditRecipe(RouteProvider routeProvider) {\n     RouteHandle route = routeProvider.route.newHandle();\n     _loadRecipe(route);\n     route.onPreLeave.listen((RouteEvent event) {\n       event.allowLeave(_checkIfOkToLeave());\n     });\n   }\n\n   /// Check if the editor has unsaved contents and if necessary ask\n   /// the user if OK to leave this page.\n   Future&lt;bool&gt; _checkIfOkToLeave() =&gt; /* ... */;\n\n   detach() {\n     route.discard();\n   }\n }\n</code></pre>\n<p> <a>angular/route-client.Route.onPreLeave</a> event is triggered when the browser is routed from an\n active route to a different route. The active route can delay and\n potentially veto the navigation by passing a Future&lt;<a>dart-core</a>> to\n <a>angular/route-client.RoutePreLeaveEvent.allowLeave</a>.</p>\n<p> Notice that we create a <a>angular/route-client.RouteHandle</a> for our route. <a>angular/route-client.RouteHandle</a> are\n a convenient wrapper around <a>angular/route-client.Route</a> that makes unsubscribing route events\n easier. For example, notice that we didn't need to manually call\n <a>angular/dart-async.StreamSubscription.cancel</a> for subscription to <a>angular/route-client.Route.onPreLeave</a>. Calling\n <a>angular/route-client.RouteHandle.discard</a> unsubscribes all listeners created for the handle.</p>\n<h2>Hierarchical Routes</h2>\n<p> The routing framework allows us to define trees of routes. In our recipes\n example we could have defined our routes like this:</p>\n<pre><code>void initRoutes(Router router, RouteViewFactory view) {\n   views.configure({\n       'recipes': ngRoute(path: '/recipes', view: 'recipes.html'),\n       'addRecipe': ngRoute(path: '/addRecipe', view: 'addRecipe.html'),\n       'recipe': ngRoute(path: '/recipe/:recipeId', mount: {\n           'view': ngRoute(path: '/view', view: 'viewRecipe.html'),\n           'edit': ngRoute(path: '/edit', view: 'editRecipe.html')\n       })\n   });\n</code></pre>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"ngRoute":{"name":"ngRoute","qualifiedName":"angular/angular-routing.ngRoute","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-routing.NgRouteCfg","inner":[]}],"parameters":{"path":{"name":"path","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"view":{"name":"view","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"viewHtml":{"name":"viewHtml","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"mount":{"name":"mount","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"angular/angular-routing.NgRouteCfg","inner":[]}]}],"value":null,"annotations":[]},"modules":{"name":"modules","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}},"defaultRoute":{"name":"defaultRoute","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]},"preEnter":{"name":"preEnter","optional":true,"named":true,"default":false,"type":[{"outer":"route-client.RoutePreEnterEventHandler","inner":[]}],"value":null,"annotations":[]},"enter":{"name":"enter","optional":true,"named":true,"default":false,"type":[{"outer":"route-client.RouteEnterEventHandler","inner":[]}],"value":null,"annotations":[]},"preLeave":{"name":"preLeave","optional":true,"named":true,"default":false,"type":[{"outer":"route-client.RoutePreLeaveEventHandler","inner":[]}],"value":null,"annotations":[]},"leave":{"name":"leave","optional":true,"named":true,"default":false,"type":[{"outer":"route-client.RouteLeaveEventHandler","inner":[]}],"value":null,"annotations":[]},"dontLeaveOnParamChanges":{"name":"dontLeaveOnParamChanges","optional":true,"named":true,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"false","annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"NgBindRoute","qualifiedName":"angular/angular-routing.NgBindRoute","preview":"<p>A directive that allows to bind child components/directives to a specific\nroute.</p>"},{"name":"NgRouteCfg","qualifiedName":"angular/angular-routing.NgRouteCfg"},{"name":"NgRoutingHelper","qualifiedName":"angular/angular-routing.NgRoutingHelper","preview":"<p>A singleton helper service that handles routing initialization, global\nevents and view registries.</p>"},{"name":"NgRoutingUsePushState","qualifiedName":"angular/angular-routing.NgRoutingUsePushState","preview":"<p>Allows configuration of Router.useFragment. By default <a>angular/angular-routing.NgRoutingUsePushState.usePushState</a> is\ntrue, so the router will listen to <a>angular/dart-dom-html.Window.onPopState</a> and route URLs like\n\"http://host:port/foo/bar?baz=qux\". Both the path and query parts of the URL\nare used by the router. If <a>angular/angular-routing.NgRoutingUsePushState.usePushState</a> is false, router will listen to\n<a>angular/dart-dom-html.Window.onHashChange</a> and route URLs like\n\"http://host:port/path#/foo/bar?baz=qux\". Everything after hash (#) is used\nby the router.</p>"},{"name":"NgView","qualifiedName":"angular/angular-routing.NgView","preview":"<p>A directive that works with the <a>angular/route-client.Router</a> and loads the template associated\nwith the current route.</p>"},{"name":"RouteInitializer","qualifiedName":"angular/angular-routing.RouteInitializer","preview":"<p>An interface that must be implemented by the user of routing library and\nshould include the route initialization.</p>"},{"name":"RouteProvider","qualifiedName":"angular/angular-routing.RouteProvider","preview":"<p>Class that can be injected to retrieve information about the current route.\nFor example:</p>"},{"name":"RouteViewFactory","qualifiedName":"angular/angular-routing.RouteViewFactory","preview":"<p>A factory of route to template bindings.</p>"},{"name":"RoutingModule","qualifiedName":"angular/angular-routing.RoutingModule"}],"typedef":{"RouteInitializerFn":{"name":"RouteInitializerFn","qualifiedName":"angular/angular-routing.RouteInitializerFn","comment":"<p>An typedef that must be implemented by the user of routing library and\nshould include the route initialization.</p>\n<p>The function will be called by the framework once the router is\ninstantiated but before NgBindRouteDirective and NgViewDirective.</p>","return":"void","parameters":{"router":{"name":"router","optional":false,"named":false,"default":false,"type":[{"outer":"route-client.Router","inner":[]}],"value":null,"annotations":[]},"viewFactory":{"name":"viewFactory","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-routing.RouteViewFactory","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>An typedef that must be implemented by the user of routing library and\nshould include the route initialization.</p>"}},"error":[]},"packageName":"angular","packageIntro":"<h1>AngularDart</h1>\n<p>A port of <a href=\"http://angularjs.org/\">Angular</a> to <a href=\"http://www.dartlang.org\">Dart</a>.</p>\n<h2>Installing</h2>\n<p>Follow the instructions on <a href=\"http://pub.dartlang.org/packages/angular#installing\">AngularDart's page on pub</a>.</p>\n<h2>API documentation</h2>\n<p>Read the autogenerated <a href=\"https://docs.angulardart.org\">API documentation</a>.</p>\n<h2>Learning more</h2>\n<p>Study the <a href=\"https://angulardart.org/tutorial\">AngularDart Tutorial</a> to learn more about Angular\nin Dart.</p>\n<h2>Joining the discussion</h2>\n<p>Discuss AngularDart on the <a href=\"https://groups.google.com/forum/#!forum/angular-dart\">mailing list</a>,\nask questions on <a href=\"http://stackoverflow.com/questions/tagged/angular.dart\">StackOverflow</a>,\nfollow <a href=\"https://plus.google.com/117340875933142003564/posts\">+AngularDart on Google+</a>,\nand follow <a href=\"https://twitter.com/AngularDart\">@AngularDart</a> and <a href=\"https://twitter.com/AngularJS\">@AngularJS</a> on Twitter.</p>\n<h2>Filing bugs</h2>\n<p>Please file bugs and feature requests using the <a href=\"https://github.com/angular/angular.dart/issues?state=open\">Github Issues Tracker</a>.</p>\n<h2>I want to help</h2>\n<p>Excellent read up on <a href=\"https://github.com/angular/angular.dart/blob/master/CONTRIBUTING.md\">contributing</a>.</p>"}
{"name":"RootScope","qualifiedName":"angular/angular-core.RootScope","comment":"<p>Every Angular application has exactly one RootScope. RootScope extends Scope, adding\nservices related to change detection, async unit-of-work processing, and DOM read/write queues.\nThe RootScope can not be destroyed.</p>\n<h2>Lifecycle</h2>\n<p>All work in Angular must be done within a context of a VmTurnZone. VmTurnZone detects the end\nof the VM turn, and calls the Apply method to process the changes at the end of VM turn.</p>","isAbstract":false,"superclass":"angular/angular-core.Scope","implements":[],"subclass":[],"variables":{"STATE_APPLY":{"name":"STATE_APPLY","qualifiedName":"angular/angular-core.RootScope.STATE_APPLY","comment":"","final":true,"static":true,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"STATE_DIGEST":{"name":"STATE_DIGEST","qualifiedName":"angular/angular-core.RootScope.STATE_DIGEST","comment":"","final":true,"static":true,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"STATE_FLUSH":{"name":"STATE_FLUSH","qualifiedName":"angular/angular-core.RootScope.STATE_FLUSH","comment":"","final":true,"static":true,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"STATE_FLUSH_ASSERT":{"name":"STATE_FLUSH_ASSERT","qualifiedName":"angular/angular-core.RootScope.STATE_FLUSH_ASSERT","comment":"","final":true,"static":true,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"astCache":{"name":"astCache","qualifiedName":"angular/angular-core.RootScope.astCache","comment":"","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"angular/angular-core.AST","inner":[]}]}],"annotations":[]}},"inheritedVariables":{"context":{"name":"context","qualifiedName":"angular/angular-core.Scope.context","comment":"<p>The default execution context for <a>angular/angular-core.RootScope.watch</a>es observeers, and <a>angular/angular-core.RootScope.eval</a>uation.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"id":{"name":"id","qualifiedName":"angular/angular-core.Scope.id","comment":"","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"rootScope":{"name":"rootScope","qualifiedName":"angular/angular-core.Scope.rootScope","comment":"<p>The <a>angular/angular-core.RootScope</a> of the application.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"angular/angular-core.RootScope","inner":[]}],"annotations":[]}},"methods":{"setters":{},"getters":{"isAttached":{"name":"isAttached","qualifiedName":"angular/angular-core.RootScope.isAttached","comment":"<p>true when the scope is still attached to the <a>angular/angular-core.RootScope</a>.</p>","commentFrom":"angular-core.Scope.isAttached","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"rootScope":{"name":"rootScope","qualifiedName":"angular/angular-core.RootScope.rootScope","comment":"","commentFrom":"angular-core.RootScope.rootScope","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.RootScope","inner":[]}],"parameters":{},"annotations":[]},"state":{"name":"state","qualifiedName":"angular/angular-core.RootScope.state","comment":"<p>While processing data bindings, Angular passes through multiple states. When testing or\ndebugging, it can be useful to access the current <code>state</code>, which is one of the following:</p><ul><li><code>null</code></li><li><code>STATE_APPLY</code></li><li><code>STATE_DIGEST</code></li><li><code>STATE_FLUSH</code></li><li><code>STATE_FLUSH_ASSERT</code></li></ul>\n<h2><code>null</code></h2>\n<p> Angular is not currently processing changes</p>\n<h2><code>STATE_APPLY</code></h2>\n<p>The apply state begins by executing the optional expression within the context of\nangular change detection mechanism. Any exceptions are delegated to <a>angular/angular-core.ExceptionHandler</a>. At the\nend of apply state RootScope enters the digest followed by flush phase (optionally if asserts\nenabled run assert phase.)</p>\n<h2><code>STATE_DIGEST</code></h2>\n<p>The apply state begins by processing the async queue,\nfollowed by change detection\non non-DOM listeners. Any changes detected are process using the reaction function. The digest\nphase is repeated as long as at least one change has been detected. By default, after 5\niterations the model is considered unstable and angular exists with an exception. (See\nScopeDigestTTL)</p>\n<h2><code>STATE_FLUSH</code></h2>\n<p>The flush phase consists of these steps:</p><ol><li>processing the DOM write queue</li><li>\n<p>change detection on DOM only updates (these are reaction functions which must\n   not change the model state and hence don't need stabilization as in digest phase).</p></li><li>processing the DOM read queue</li><li>repeat steps 1 and 3 (not 2) until queues are empty</li></ol>\n<h2><code>STATE_FLUSH_ASSERT</code></h2>\n<p>Optionally if Dart assert is on, verify that flush reaction functions did not make any changes\nto model and throw error if changes detected.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"angular/angular-core.RootScope.RootScope-","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"context":{"name":"context","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]},"parser":{"name":"parser","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.Parser","inner":[]}],"value":null,"annotations":[]},"astParser":{"name":"astParser","optional":false,"named":false,"default":false,"type":[{"outer":"angular-change_detection-ast_parser.ASTParser","inner":[]}],"value":null,"annotations":[]},"fieldGetterFactory":{"name":"fieldGetterFactory","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.FieldGetterFactory","inner":[]}],"value":null,"annotations":[]},"formatters":{"name":"formatters","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.FormatterMap","inner":[]}],"value":null,"annotations":[]},"_exceptionHandler":{"name":"_exceptionHandler","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.ExceptionHandler","inner":[]}],"value":null,"annotations":[]},"_ttl":{"name":"_ttl","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.ScopeDigestTTL","inner":[]}],"value":null,"annotations":[]},"_zone":{"name":"_zone","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.VmTurnZone","inner":[]}],"value":null,"annotations":[]},"_scopeStats":{"name":"_scopeStats","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.ScopeStats","inner":[]}],"value":null,"annotations":[]},"cacheRegister":{"name":"cacheRegister","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.CacheRegister","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{"destroy":{"name":"destroy","qualifiedName":"angular/angular-core.RootScope.destroy","comment":"<p>Removes the current scope (and all of its children) from the parent scope. Removal implies\nthat calls to <a>angular/angular-core.RootScope.digest</a> will no longer propagate to the current scope nor its children.</p>\n<p>The <code>destroy()</code> operation is usually used within directives that perform transclusion on\nmultiple child elements (like ngRepeat) which create multiple child scopes.</p>\n<p>Just before a scope is destroyed, a <a>angular/angular-core_internal.ScopeEvent.DESTROY</a> event is broadcasted from this scope.\nThis allows for child scopes (such as shared directives) to perform any necessary cleanup\nbefore the scope is removed from the application.</p>","commentFrom":"angular-core.Scope.destroy","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"digest":{"name":"digest","qualifiedName":"angular/angular-core.RootScope.digest","comment":"<p>Propagates changes between different parts of the application model. Normally called by\nVMTurnZone right before DOM rendering to initiate data binding. May also be called directly\nfor unit testing.</p>\n<p>Before each iteration of change detection, <a>angular/angular-core.RootScope.digest</a> first processes the async queue. Any\nwork scheduled on the queue is executed before change detection. Since work scheduled on\nthe queue may generate more async calls, <a>angular/angular-core.RootScope.digest</a> must process the queue multiple times before\nit completes. The async queue must be empty before the model is considered stable.</p>\n<p>Next, <a>angular/angular-core.RootScope.digest</a> collects the changes that have occurred in the model. For each change,\n<a>angular/angular-core.RootScope.digest</a> calls the associated <a>angular/angular-core.ReactionFn</a>. Since a <a>angular/angular-core.ReactionFn</a> may further change the model,\n<a>angular/angular-core.RootScope.digest</a> processes changes multiple times until no more changes are detected.</p>\n<p>If the model does not stabilize within 10 iterations, an exception is thrown. See\n<a>angular/angular-core.ScopeDigestTTL</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"flush":{"name":"flush","qualifiedName":"angular/angular-core.RootScope.flush","comment":"","commentFrom":"angular-core.RootScope.flush","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"runAsync":{"name":"runAsync","qualifiedName":"angular/angular-core.RootScope.runAsync","comment":"","commentFrom":"angular-core.RootScope.runAsync","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hasOwnStreams":{"name":"hasOwnStreams","qualifiedName":"angular/angular-core.RootScope.hasOwnStreams","comment":"<p>Do not use. Exposes internal state for testing.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.hasOwnStreams","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"angular/angular-core.RootScope.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>angular/angular-core.RootScope.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"isAttached":{"name":"isAttached","qualifiedName":"angular/angular-core.RootScope.isAttached","comment":"<p>true when the scope is still attached to the <a>angular/angular-core.RootScope</a>.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.isAttached","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isDestroyed":{"name":"isDestroyed","qualifiedName":"angular/angular-core.RootScope.isDestroyed","comment":"<p>Return <code>true</code> if the scope has been destroyed. Once scope is destroyed\nNo operations are allowed on it.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.isDestroyed","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"parentScope":{"name":"parentScope","qualifiedName":"angular/angular-core.RootScope.parentScope","comment":"","commentFrom":"","inheritedFrom":"angular-core.Scope.parentScope","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.Scope","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"angular/angular-core.RootScope.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"angular/angular-core.RootScope.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>angular/angular-core.RootScope.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>angular/angular-core.RootScope.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"apply":{"name":"apply","qualifiedName":"angular/angular-core.RootScope.apply","comment":"<p>Triggers a digest cycle. It accepts an optional <a>angular/angular-core.RootScope.apply.expression</a> to evaluate before the digest\noperation. The result of that expression will be returned afterwards.</p>\n<p><a>angular/angular-core.RootScope.apply</a> should only be called from the within unit tests to simulate the life cycle of a scope.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.apply","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"expression":{"name":"expression","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"locals":{"name":"locals","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"broadcast":{"name":"broadcast","qualifiedName":"angular/angular-core.RootScope.broadcast","comment":"<p>Triggers a <a>angular/angular-core.ScopeEvent</a> referenced by the <a>angular/angular-core.RootScope.broadcast.name</a> parameters downards towards the leaf nodes of\nthe scope tree. If intercepted, by a child scope containing a matching scope event listener\n(which is registered via the <a>angular/angular-core.RootScope.on</a> method), then the event listener callback function will be\nexecuted.</p>\n<p>The triggered <a>angular/angular-core.ScopeEvent</a> references the <a>angular/angular-core.RootScope.broadcast.data</a> so that they can be retrieve in the listener.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.broadcast","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.ScopeEvent","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"data":{"name":"data","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"createChild":{"name":"createChild","qualifiedName":"angular/angular-core.RootScope.createChild","comment":"<p>Creates a child <a>angular/angular-core.Scope</a> with the given <a>angular/angular-core.RootScope.createChild.childContext</a></p>","commentFrom":"","inheritedFrom":"angular-core.Scope.createChild","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.Scope","inner":[]}],"parameters":{"childContext":{"name":"childContext","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"destroy":{"name":"destroy","qualifiedName":"angular/angular-core.RootScope.destroy","comment":"<p>Removes the current scope (and all of its children) from the parent scope. Removal implies\nthat calls to <a>angular/angular-core.RootScope.digest</a> will no longer propagate to the current scope nor its children.</p>\n<p>The <code>destroy()</code> operation is usually used within directives that perform transclusion on\nmultiple child elements (like ngRepeat) which create multiple child scopes.</p>\n<p>Just before a scope is destroyed, a <a>angular/angular-core_internal.ScopeEvent.DESTROY</a> event is broadcasted from this scope.\nThis allows for child scopes (such as shared directives) to perform any necessary cleanup\nbefore the scope is removed from the application.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.destroy","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"domRead":{"name":"domRead","qualifiedName":"angular/angular-core.RootScope.domRead","comment":"<p>Internal. Use View.domRead instead.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.domRead","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}}},"annotations":[]},"domWrite":{"name":"domWrite","qualifiedName":"angular/angular-core.RootScope.domWrite","comment":"<p>Internal. Use View.domWrite instead.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.domWrite","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}}},"annotations":[]},"emit":{"name":"emit","qualifiedName":"angular/angular-core.RootScope.emit","comment":"<p>Triggers a <a>angular/angular-core.ScopeEvent</a> referenced by the <a>angular/angular-core.RootScope.emit.name</a> parameters upwards towards the root of the\nscope tree. If intercepted, by a parent scope containing a matching scope event listener\n(which is registered via the <a>angular/angular-core.RootScope.on</a> method), then the event listener callback function will be\nexecuted.</p>\n<p>The triggered <a>angular/angular-core.ScopeEvent</a> references the <a>angular/angular-core.RootScope.emit.data</a> so that they can be retrieve in the listener.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.emit","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.ScopeEvent","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"data":{"name":"data","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"eval":{"name":"eval","qualifiedName":"angular/angular-core.RootScope.eval","comment":"<p>Evaluates the <a>angular/angular-core.RootScope.eval.expression</a> against the current scope and returns the result. Note that, the\nexpression data is relative to the data within the scope. Therefore an expression such as\n<code>a + b</code> will deference variables <code>a</code> and <code>b</code> and return a result so long as <code>a</code> and <code>b</code>\nexist on the scope.</p><ul><li>\n<p><a>angular/angular-core.RootScope.eval.expression</a>: The expression that will be evaluated. This can be either a Function or a\n  String.</p></li><li>\n<p><a>angular/angular-core.RootScope.eval.locals</a>: A Map that will override any matching context members for the purposes of the\n  evaluation.</p></li></ul>","commentFrom":"","inheritedFrom":"angular-core.Scope.eval","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"expression":{"name":"expression","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"locals":{"name":"locals","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"angular/angular-core.RootScope.noSuchMethod","comment":"<p><a>angular/angular-core.RootScope.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>angular/angular-core.RootScope.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>angular/angular-core.RootScope.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>angular/angular-core.RootScope.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"on":{"name":"on","qualifiedName":"angular/angular-core.RootScope.on","comment":"<p>Registers a scope-based event listener to intercept events triggered by <a>angular/angular-core.RootScope.broadcast</a> (from any\nparent scopes) or <a>angular/angular-core.RootScope.emit</a> (from child scopes) that match the given event <a>angular/angular-core.RootScope.on.name</a>.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.on","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular-core_internal.ScopeStream","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"angular/angular-core.RootScope.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"watch":{"name":"watch","qualifiedName":"angular/angular-core.RootScope.watch","comment":"<p>Use <a>angular/angular-core.RootScope.watch</a> to set up change detection on an expression.</p><ul><li>\n<p><a>angular/angular-core.RootScope.watch.expression</a>: The expression to watch for changes.\n  Expressions may use a special notation in addition to what is supported by the parser.\n  In particular:</p></li><li>\n<p>If an expression begins with '::', it is unwatched as soon as it evaluates to a non-null\n  value.</p></li><li>\n<p>If an expression begins with ':', it only calls the <a>angular/angular-core.RootScope.watch.reactionFn</a> if the expression\n  evaluates to a non-null value.</p></li><li>\n<p><a>angular/angular-core.RootScope.watch.reactionFn</a>: The reaction function to execute when a change is detected in the watched\n  expression.</p></li><li>\n<p><a>angular/angular-core.RootScope.watch.formatters</a>: If the watched expression contains formatters,\n  this map specifies the set of formatters that are used by the expression.</p></li><li>\n<p><a>angular/angular-core.RootScope.watch.canChangeModel</a>: Specifies whether the <a>angular/angular-core.RootScope.watch.reactionFn</a> changes the model. Reaction\n  functions that change the model are processed as part of the <a>angular/angular-core.RootScope.digest</a> cycle. Otherwise,\n  they are processed as part of the <a>angular/angular-core.RootScope.flush</a> cycle.</p></li><li>\n<p><a>angular/angular-core.RootScope.watch.collection</a>: If <code>true</code>, then the expression points to a collection (a list or a map),\n  and the collection should be shallow watched. If <code>false</code> then the expression is watched\n  by reference. When watching a collection, the reaction function receives a\n  <a>angular/change_detection.CollectionChangeItem</a> that lists all the changes.</p></li></ul>","commentFrom":"","inheritedFrom":"angular-core.Scope.watch","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.Watch","inner":[]}],"parameters":{"expression":{"name":"expression","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"reactionFn":{"name":"reactionFn","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.ReactionFn","inner":[]}],"value":null,"annotations":[]},"context":{"name":"context","optional":true,"named":true,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"formatters":{"name":"formatters","optional":true,"named":true,"default":false,"type":[{"outer":"angular/angular-core.FormatterMap","inner":[]}],"value":null,"annotations":[]},"canChangeModel":{"name":"canChangeModel","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]},"collection":{"name":"collection","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"watchAST":{"name":"watchAST","qualifiedName":"angular/angular-core.RootScope.watchAST","comment":"<p>Use <a>angular/angular-core.RootScope.watch</a> to set up change detection on an pre-parsed AST.</p><ul><li><a>angular/angular-core.RootScope.watchAST.ast</a>: The pre-parsed AST.</li><li><a>angular/angular-core.RootScope.watchAST.reactionFn</a>: The function executed when a change is detected.</li><li><a>angular/angular-core.RootScope.watchAST.canChangeModel</a>: Whether or not the <a>angular/angular-core.RootScope.watchAST.reactionFn</a> can change the model.</li></ul>","commentFrom":"","inheritedFrom":"angular-core.Scope.watchAST","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular/angular-core.Watch","inner":[]}],"parameters":{"ast":{"name":"ast","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.AST","inner":[]}],"value":null,"annotations":[]},"reactionFn":{"name":"reactionFn","optional":false,"named":false,"default":false,"type":[{"outer":"angular/angular-core.ReactionFn","inner":[]}],"value":null,"annotations":[]},"canChangeModel":{"name":"canChangeModel","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]}}},"annotations":[{"name":"angular/di-annotations.Injectable","parameters":[]}],"generics":{}}
{"name":"angular-core","qualifiedName":"angular-core","comment":"","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"NOT_IMPLEMENTED":{"name":"NOT_IMPLEMENTED","qualifiedName":"angular-core.NOT_IMPLEMENTED","comment":"","commentFrom":"","inheritedFrom":"","static":"false","abstract":"false","constant":"false","return":[{"outer":"dynamic","inner":[]}],"parameters":{},"annotations":[]}}},"classes":{"class":[{"name":"NgInjectableService","qualifiedName":"angular-core.NgInjectableService","preview":"<p>An annotation when applied to a class indicates that the class (service) will\nbe instantiated by di injector.</p>"},{"name":"PrototypeMap","qualifiedName":"angular-core.PrototypeMap"},{"name":"CollectionAST","qualifiedName":"angular-core.CollectionAST"},{"name":"MethodAST","qualifiedName":"angular-core.MethodAST","preview":"<p>SYNTAX: lhs.method(arg0, arg1, ...)</p>"},{"name":"PureFunctionAST","qualifiedName":"angular-core.PureFunctionAST","preview":"<p>SYNTAX: fn(arg0, arg1, ...)</p>"},{"name":"FieldReadAST","qualifiedName":"angular-core.FieldReadAST","preview":"<p>SYNTAX: lhs.name.</p>"},{"name":"ConstantAST","qualifiedName":"angular-core.ConstantAST","preview":"<p>SYNTAX: <em>context</em></p>"},{"name":"ContextReferenceAST","qualifiedName":"angular-core.ContextReferenceAST","preview":"<p>SYNTAX: <em>context</em></p>"},{"name":"AST","qualifiedName":"angular-core.AST","preview":"<p>RULES:\n - ASTs are reusable. Don't store scope/instance refs there\n - Parent knows about children, not the other way around.</p>"},{"name":"Watch","qualifiedName":"angular-core.Watch","preview":"<p><a>angular-core.Watch</a> corresponds to an individual watch registration on the watchGrp.</p>"},{"name":"RootWatchGroup","qualifiedName":"angular-core.RootWatchGroup","preview":"<p><a>angular-core.RootWatchGroup</a></p>"},{"name":"WatchGroup","qualifiedName":"angular-core.WatchGroup","preview":"<p><a>angular-core.WatchGroup</a> is a logical grouping of a set of watches. <a>angular-core.WatchGroup</a>s are\norganized into a hierarchical tree parent-children configuration.\n<a>angular-core.WatchGroup</a> builds upon <a>change_detection.ChangeDetector</a> and adds expression (field chains\nas in <code>a.b.c</code>) support as well as support function/closure/method (function\ninvocation as in <code>a.b()</code>) watching.</p>"},{"name":"FunctionApply","qualifiedName":"angular-core.FunctionApply","preview":"<p>Extend this class if you wish to pretend to be a function, but you don't know\nnumber of arguments with which the function will get called.</p>"},{"name":"NgZone","qualifiedName":"angular-core.NgZone","preview":"<p>A better zone API which implements onTurnDone.</p>"},{"name":"LongStackTrace","qualifiedName":"angular-core.LongStackTrace","preview":"<p>Contains the locations of runAsync calls across VM turns.</p>"},{"name":"MapFn","qualifiedName":"angular-core.MapFn"},{"name":"ArrayFn","qualifiedName":"angular-core.ArrayFn"},{"name":"ExpressionVisitor","qualifiedName":"angular-core.ExpressionVisitor"},{"name":"AstParser","qualifiedName":"angular-core.AstParser"},{"name":"ScopeStreamSubscription","qualifiedName":"angular-core.ScopeStreamSubscription"},{"name":"ScopeStream","qualifiedName":"angular-core.ScopeStream"},{"name":"RootScope","qualifiedName":"angular-core.RootScope"},{"name":"Scope","qualifiedName":"angular-core.Scope","preview":"<p><a>angular-core.Scope</a> is represents a collection of <a>angular-core.Scope.watch</a>es observeers, and <a>angular-core.Scope.context</a>\nfor the watchers, observers and <a>angular-core.Scope.eval</a>uations. Scopes structure loosely\nmimics the DOM structure. Scopes and Blocks are bound to each other.\nAs scopes are created and destroyed by BlockFactory they are responsible\nfor change detection, change processing and memory management.</p>"},{"name":"ScopeLocals","qualifiedName":"angular-core.ScopeLocals"},{"name":"ScopeDigestTTL","qualifiedName":"angular-core.ScopeDigestTTL","preview":"<p>Allows the configuration of Scope.digest iteration maximum time-to-live\nvalue. Digest keeps checking the state of the watcher getters until it\ncan execute one full iteration with no watchers triggering. TTL is used\nto prevent an infinite loop where watch A triggers watch B which in turn\ntriggers watch A. If the system does not stabilize in TTL iterations then\nthe digest is stopped and an exception is thrown.</p>"},{"name":"ScopeEvent","qualifiedName":"angular-core.ScopeEvent","preview":"<p>Injected into the listener function within <a>angular-core.Scope.on</a> to provide\nevent-specific details to the scope listener.</p>"},{"name":"MetadataExtractor","qualifiedName":"angular-core.MetadataExtractor"},{"name":"AnnotationsMap","qualifiedName":"angular-core.AnnotationsMap"},{"name":"AnnotationMap","qualifiedName":"angular-core.AnnotationMap"},{"name":"Interpolate","qualifiedName":"angular-core.Interpolate","preview":"<p>Compiles a string with markup into an interpolation function. This service\nis used by the HTML Compiler service for data binding.</p>"},{"name":"Interpolation","qualifiedName":"angular-core.Interpolation"},{"name":"FilterMap","qualifiedName":"angular-core.FilterMap","preview":"<p>Registry of filters at runtime.</p>"},{"name":"NgFilter","qualifiedName":"angular-core.NgFilter","preview":"<p>Use @<a>angular-core.NgFilter</a> annotation to register a new filter. A filter is a class\nwith a call method (a callable function).</p>"},{"name":"ExceptionHandler","qualifiedName":"angular-core.ExceptionHandler","preview":"<p>Any uncaught exception in angular expressions is delegated to this service.\nThe default implementation logs exceptions into console.</p>"},{"name":"NgDetachAware","qualifiedName":"angular-core.NgDetachAware","preview":"<p>Implementing directives or components <a>angular-core.NgDetachAware.detach</a> method will be called when\nthe associated scope is destroyed.</p>"},{"name":"NgAttachAware","qualifiedName":"angular-core.NgAttachAware","preview":"<p>Implementing directives or components <a>angular-core.NgAttachAware.attach</a> method will be called when\nthe next scope digest occurs after component instantiation. It is guaranteed\nthat when <a>angular-core.NgAttachAware.attach</a> is invoked, that all attribute mappings have already\nbeen processed.</p>"},{"name":"NgCallback","qualifiedName":"angular-core.NgCallback","preview":"<p>When applied as an annotation on a directive field specifies that\nthe field is to be mapped to DOM attribute with the provided <a>angular-core.AttrFieldAnnotation.attrName</a>.\nThe value of the attribute to be treated as a callback expession,\nequivalent to <code>&amp;</code> specification.</p>"},{"name":"NgTwoWay","qualifiedName":"angular-core.NgTwoWay","preview":"<p>When applied as an annotation on a directive field specifies that\nthe field is to be mapped to DOM attribute with the provided <a>angular-core.AttrFieldAnnotation.attrName</a>.\nThe value of the attribute to be treated as a two-way expession,\nequivalent to <code>&lt;=&gt;</code> specification.</p>"},{"name":"NgOneWayOneTime","qualifiedName":"angular-core.NgOneWayOneTime","preview":"<p>When applied as an annotation on a directive field specifies that\nthe field is to be mapped to DOM attribute with the provided <a>angular-core.AttrFieldAnnotation.attrName</a>.\nThe value of the attribute to be treated as a one time one-way expession,\nequivalent to <code>=&gt;!</code> specification.</p>"},{"name":"NgOneWay","qualifiedName":"angular-core.NgOneWay","preview":"<p>When applied as an annotation on a directive field specifies that\nthe field is to be mapped to DOM attribute with the provided <a>angular-core.AttrFieldAnnotation.attrName</a>.\nThe value of the attribute to be treated as a one-way expession, equivalent\nto <code>=&gt;</code> specification.</p>"},{"name":"NgAttr","qualifiedName":"angular-core.NgAttr","preview":"<p>When applied as an annotation on a directive field specifies that\nthe field is to be mapped to DOM attribute with the provided <a>angular-core.AttrFieldAnnotation.attrName</a>.\nThe value of the attribute to be treated as a string, equivalent\nto <code>@</code> specification.</p>"},{"name":"AttrFieldAnnotation","qualifiedName":"angular-core.AttrFieldAnnotation"},{"name":"NgController","qualifiedName":"angular-core.NgController","preview":"<p>Meta-data marker placed on a class which should act as a controller for your application.</p>"},{"name":"NgDirective","qualifiedName":"angular-core.NgDirective","preview":"<p>Meta-data marker placed on a class which should act as a directive.</p>"},{"name":"NgComponent","qualifiedName":"angular-core.NgComponent","preview":"<p>Meta-data marker placed on a class which should act as a controller for the\ncomponent. Angular components are a light-weight version of web-components.\nAngular components use shadow-DOM for rendering their templates.</p>"},{"name":"NgAnnotation","qualifiedName":"angular-core.NgAnnotation"},{"name":"LruCache","qualifiedName":"angular-core.LruCache","preview":"<p>Simple LRU cache.</p>"},{"name":"UnboundedCache","qualifiedName":"angular-core.UnboundedCache","preview":"<p>An unbounded cache.</p>"},{"name":"Cache","qualifiedName":"angular-core.Cache","preview":"<p>The Cache interface.</p>"},{"name":"CacheStats","qualifiedName":"angular-core.CacheStats"},{"name":"NgCoreModule","qualifiedName":"angular-core.NgCoreModule"}],"typedef":{"ChangeLog":{"name":"ChangeLog","qualifiedName":"angular-core.ChangeLog","comment":"","return":"dynamic","parameters":{"expression":{"name":"expression","optional":"false","named":"false","default":"false","type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"current":{"name":"current","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"previous":{"name":"previous","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[],"generics":{}},"ReactionFn":{"name":"ReactionFn","qualifiedName":"angular-core.ReactionFn","comment":"","return":"dynamic","parameters":{"value":{"name":"value","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"previousValue":{"name":"previousValue","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[],"generics":{}},"ZoneOnError":{"name":"ZoneOnError","qualifiedName":"angular-core.ZoneOnError","comment":"","return":"void","parameters":{"error":{"name":"error","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"stacktrace":{"name":"stacktrace","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"longStacktrace":{"name":"longStacktrace","optional":"false","named":"false","default":"false","type":[{"outer":"angular-core.LongStackTrace","inner":[]}],"value":"null","annotations":[]}},"annotations":[],"generics":{}},"ZoneOnTurn":{"name":"ZoneOnTurn","qualifiedName":"angular-core.ZoneOnTurn","comment":"","return":"void","parameters":{},"annotations":[],"generics":{}},"EvalFunction1":{"name":"EvalFunction1","qualifiedName":"angular-core.EvalFunction1","comment":"","return":"dynamic","parameters":{"context":{"name":"context","optional":"false","named":"false","default":"false","type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[],"generics":{}},"EvalFunction0":{"name":"EvalFunction0","qualifiedName":"angular-core.EvalFunction0","comment":"","return":"dynamic","parameters":{},"annotations":[],"generics":{}}},"error":[]},"packageName":"","packageIntro":""}
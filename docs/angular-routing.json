{"name":"angular-routing","qualifiedName":"angular-routing","comment":"<p>Route configuration for single-page applications.</p>\n<p>The routing library makes it easier to build large single-page\napplications. The library lets you map the browser address bar to semantic\nstructure of your application and keeps them in sync.</p>\n<p>Angular uses the route_hierarchical package to define application routes\nand to provide custom tools to make it easier to use routing with Angular\ntemplates.</p>\n<p>Let's consider a simple recipe book application. The application might have\nthe following pages:</p><ul><li>recipes list/search</li><li>add new recipe</li><li>view recipe</li><li>edit recipe</li></ul>\n<p>Each of those pages can be represented by an address:</p><ul><li><code>/recipes</code></li><li><code>/addRecipe</code></li><li><code>/recipe/:recipeId/view</code></li><li><code>/recipe/:recipeId/edit</code></li></ul>\n<p>Let's try to define those routes in Angular. To get started we need to\nprovide an implementation of <a>angular-routing.RouteInitializerFn</a> function.</p>\n<pre><code> void initRoutes(Router router, RouteViewFactory view) {\n   // define routes here.\n }\n\n var module = new Module()\n     ..bind(RouteInitializerFn, toValue: initRoutes);\n</code></pre>\n<p> Let's see how we could define our routes using the routing framework:</p>\n<pre><code> void initRoutes(Router router, RouteViewFactory view) {\n   router.root\n       ..addRoute(\n           name: 'recipes',\n           path: '/recipes',\n           enter: view('recipes.html'))\n       ..addRoute(\n           name: 'addRecipe',\n           path: '/addRecipe',\n           enter: view('addRecipe.html'))\n       ..addRoute(\n           name: 'viewRecipe',\n           path: '/recipe/:recipeId/view',\n           enter: view('viewRecipe.html'))\n       ..addRoute(\n           name: 'editRecipe',\n           path: '/recipe/:recipeId/edit',\n           enter: view('editRecipe.html'));\n }\n</code></pre>\n<p> We defined 4 routes and for each route we set views (templates) to be\n displayed when that route is \"entered\". For example, when the browser URL\n is set to <code>/recipes</code>, the <code>recipes.html</code> will be displayed.</p>\n<p> You have to tell Angular where to load views by putting <code>&lt;ng-view&gt;</code> tag in\n you template.</p>\n<p> Notice that <code>viewRecipe</code> and <code>editRecipe</code> route paths have <code>recipeId</code>\n parameter in them. We need to be able to get hold of that parameter in\n order to know which recipe to load. Let's consider the following\n <code>viewRecipe.html</code>.</p>\n<pre><code> &lt;view-recipe&gt;&lt;/view-recipe&gt;\n</code></pre>\n<p> The template contains a custom <code>view-recipe</code> component that handles\n displaying the recipe. Now, our <code>view-recipe</code> can inject <a>angular-routing.RouteProvider</a>\n to get hold of the route and its parameters. It might look like this:</p>\n<pre><code> @Component(...)\n class ViewRecipe {\n   ViewRecipe(RouteProvider routeProvider) {\n     String recipeId = routeProvider.parameters['recipeId'];\n     _loadRecipe(recipeId);\n   }\n }\n</code></pre>\n<p> <a>angular-routing.RouteProvider</a> and <a>route-client.Route</a> can be used to control navigation, specifically,\n leaving of the route. For example, let's consider \"edit recipe\" component:</p>\n<pre><code> @Component(...)\n class EditRecipe implements DetachAware {\n   RouteHandle route;\n   EditRecipe(RouteProvider routeProvider) {\n     RouteHandle route = routeProvider.route.newHandle();\n     _loadRecipe(route);\n     route.onLeave.listen((RouteEvent event) {\n       event.allowLeave(_checkIfOkToLeave());\n     });\n   }\n\n   /// Check if the editor has unsaved contents and if necessary ask\n   /// the user if OK to leave this page.\n   Future&lt;bool&gt; _checkIfOkToLeave() {/* ... */}\n\n   detach() {\n     route.discard();\n   }\n }\n</code></pre>\n<p> <a>route-client.Route.onLeave</a> event is triggered when the browser is routed from an\n active route to a different route. The active route can delay and\n potentially veto the navigation by passing a Future&lt;<a>dart-core</a>> to\n RouteEvent.allowLeave.</p>\n<p> Notice that we create a <a>route-client.RouteHandle</a> for our route. <a>route-client.RouteHandle</a> are\n a convinient wrapper around <a>route-client.Route</a> that makes unsubscribing route events\n easier. For example, notice that we didn't need to manually call\n <a>dart-async.StreamSubscription.cancel</a> for subscription to <a>route-client.Route.onLeave</a>. Calling\n <a>route-client.RouteHandle.discard</a> unsubscribes all listeneters created for the handle.</p>\n<h2>Hierarchical Routes</h2>\n<p> The routing framework allows us to define trees of routes. In our recipes\n example we could have defined our routes like this:</p>\n<pre><code>void initRoutes(Router router, RouteViewFactory view) {\n  router.root\n      ..addRoute(\n         name: 'recipes',\n         path: '/recipes',\n         enter: view('recipes.html'))\n      ..addRoute(\n         name: 'addRecipe',\n         path: '/addRecipe',\n         enter: view('addRecipe.html'))\n      ..addRoute(\n         name: 'recipe',\n         path: '/recipe/:recipeId',\n         mount: (Route route) =&gt; route\n             ..addRoute(\n                 name: 'view',\n                 path: '/view',\n                 enter: view('viewRecipe.html'))\n             ..addRoute(\n                 name: 'edit',\n                 path: '/edit',\n                 enter: view('editRecipe.html')));\n}\n</code></pre>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"ngRoute":{"name":"ngRoute","qualifiedName":"angular-routing.ngRoute","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular-routing.NgRouteCfg","inner":[]}],"parameters":{"path":{"name":"path","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"view":{"name":"view","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"viewHtml":{"name":"viewHtml","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"mount":{"name":"mount","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"angular-routing.NgRouteCfg","inner":[]}]}],"value":null,"annotations":[]},"modules":{"name":"modules","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}},"defaultRoute":{"name":"defaultRoute","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]},"preEnter":{"name":"preEnter","optional":true,"named":true,"default":false,"type":[{"outer":"route-client.RoutePreEnterEventHandler","inner":[]}],"value":null,"annotations":[]},"enter":{"name":"enter","optional":true,"named":true,"default":false,"type":[{"outer":"route-client.RouteEnterEventHandler","inner":[]}],"value":null,"annotations":[]},"leave":{"name":"leave","optional":true,"named":true,"default":false,"type":[{"outer":"route-client.RouteLeaveEventHandler","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"NgBindRoute","qualifiedName":"angular-routing.NgBindRoute","preview":"<p>A directive that allows to bind child components/directives to a specific\nroute.</p>"},{"name":"NgRouteCfg","qualifiedName":"angular-routing.NgRouteCfg"},{"name":"NgRoutingHelper","qualifiedName":"angular-routing.NgRoutingHelper","preview":"<p>A singleton helper service that handles routing initialization, global\nevents and view registries.</p>"},{"name":"NgRoutingUsePushState","qualifiedName":"angular-routing.NgRoutingUsePushState","preview":"<p>Allows configuration of Router.useFragment. By default <a>angular-routing.NgRoutingUsePushState.usePushState</a> is\ntrue, so the router will listen to <a>dart-dom-html.Window.onPopState</a> and route URLs like\n\"http://host:port/foo/bar?baz=qux\". Both the path and query parts of the URL\nare used by the router. If <a>angular-routing.NgRoutingUsePushState.usePushState</a> is false, router will listen to\n<a>dart-dom-html.Window.onHashChange</a> and route URLs like\n\"http://host:port/path#/foo/bar?baz=qux\". Everything after hash (#) is used\nby the router.</p>"},{"name":"NgView","qualifiedName":"angular-routing.NgView","preview":"<p>A directive that works with the <a>route-client.Router</a> and loads the template associated\nwith the current route.</p>"},{"name":"RouteInitializer","qualifiedName":"angular-routing.RouteInitializer","preview":"<p>An interface that must be implemented by the user of routing library and\nshould include the route initialization.</p>"},{"name":"RouteProvider","qualifiedName":"angular-routing.RouteProvider","preview":"<p>Class that can be injected to retrieve information about the current route.\nFor example:</p>"},{"name":"RouteViewFactory","qualifiedName":"angular-routing.RouteViewFactory","preview":"<p>A factory of route to template bindings.</p>"},{"name":"RoutingModule","qualifiedName":"angular-routing.RoutingModule"}],"typedef":{"RouteInitializerFn":{"name":"RouteInitializerFn","qualifiedName":"angular-routing.RouteInitializerFn","comment":"<p>An typedef that must be implemented by the user of routing library and\nshould include the route initialization.</p>\n<p>The function will be called by the framework once the router is\ninstantiated but before NgBindRouteDirective and NgViewDirective.</p>","return":"void","parameters":{"router":{"name":"router","optional":false,"named":false,"default":false,"type":[{"outer":"route-client.Router","inner":[]}],"value":null,"annotations":[]},"viewFactory":{"name":"viewFactory","optional":false,"named":false,"default":false,"type":[{"outer":"angular-routing.RouteViewFactory","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>An typedef that must be implemented by the user of routing library and\nshould include the route initialization.</p>"}},"error":[]},"packageName":"","packageIntro":null}
{"name":"RootScope","qualifiedName":"angular-core.RootScope","comment":"<p>Every Angular application has exactly one RootScope. RootScope extends Scope, adding\nservices related to change detection, async unit-of-work processing, and DOM read/write queues.\nThe RootScope can not be destroyed.</p>\n<h2>Lifecycle</h2>\n<p>All work in Angular must be done within a context of a VmTurnZone. VmTurnZone detects the end\nof the VM turn, and calls the Apply method to process the changes at the end of VM turn.</p>","isAbstract":false,"superclass":"angular-core.Scope","implements":[],"subclass":[],"variables":{"STATE_APPLY":{"name":"STATE_APPLY","qualifiedName":"angular-core.RootScope.STATE_APPLY","comment":"","final":true,"static":true,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"STATE_DIGEST":{"name":"STATE_DIGEST","qualifiedName":"angular-core.RootScope.STATE_DIGEST","comment":"","final":true,"static":true,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"STATE_FLUSH":{"name":"STATE_FLUSH","qualifiedName":"angular-core.RootScope.STATE_FLUSH","comment":"","final":true,"static":true,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"STATE_FLUSH_ASSERT":{"name":"STATE_FLUSH_ASSERT","qualifiedName":"angular-core.RootScope.STATE_FLUSH_ASSERT","comment":"","final":true,"static":true,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]}},"inheritedVariables":{"id":{"name":"id","qualifiedName":"angular-core.Scope.id","comment":"","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"context":{"name":"context","qualifiedName":"angular-core.Scope.context","comment":"<p>The default execution context for <a>angular-core.Scope.watch</a>es observeers, and <a>angular-core.Scope.eval</a>uation.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"rootScope":{"name":"rootScope","qualifiedName":"angular-core.Scope.rootScope","comment":"<p>The <a>angular-core.RootScope</a> of the application.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"angular-core.RootScope","inner":[]}],"annotations":[]}},"methods":{"setters":{},"getters":{"state":{"name":"state","qualifiedName":"angular-core.RootScope.state","comment":"<p>While processing data bindings, Angular passes through multiple states. When testing or\ndebugging, it can be useful to access the current <code>state</code>, which is one of the following:</p><ul><li>null</li><li>apply</li><li>digest</li><li>flush</li><li>assert</li></ul>\n<h2>null</h2>\n<p> Angular is not currently processing changes</p>\n<h2>apply</h2>\n<p>The apply state begins by executing the optional expression within the context of\nangular change detection mechanism. Any exceptions are delegated to <a>angular-core.ExceptionHandler</a>. At the\nend of apply state RootScope enters the digest followed by flush phase (optionally if asserts\nenabled run assert phase.)</p>\n<h2>digest</h2>\n<p>The apply state begins by processing the async queue,\nfollowed by change detection\non non-DOM listeners. Any changes detected are process using the reaction function. The digest\nphase is repeated as long as at least one change has been detected. By default, after 5\niterations the model is considered unstable and angular exists with an exception. (See\nScopeDigestTTL)</p>\n<h2>flush</h2>\n<p>The flush phase consists of these steps:</p><ol><li>processing the DOM write queue</li><li>\n<p>change detection on DOM only updates (these are reaction functions which must\n   not change the model state and hence don't need stabilization as in digest phase).</p></li><li>processing the DOM read queue</li><li>repeat steps 1 and 3 (not 2) until queues are empty</li></ol>\n<h2>assert</h2>\n<p>Optionally if Dart assert is on, verify that flush reaction functions did not make any changes\nto model and throw error if changes detected.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"rootScope":{"name":"rootScope","qualifiedName":"angular-core.RootScope.rootScope","comment":"","commentFrom":"angular-core.RootScope.rootScope","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular-core.RootScope","inner":[]}],"parameters":{},"annotations":[]},"isAttached":{"name":"isAttached","qualifiedName":"angular-core.RootScope.isAttached","comment":"<p>Returns true if the scope is still attached to the <a>angular-core.RootScope</a>.</p>","commentFrom":"angular-core.Scope.isAttached","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"angular-core.RootScope.RootScope-","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"context":{"name":"context","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":"null","annotations":[]},"parser":{"name":"parser","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core.Parser","inner":[]}],"value":"null","annotations":[]},"fieldGetterFactory":{"name":"fieldGetterFactory","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core.FieldGetterFactory","inner":[]}],"value":"null","annotations":[]},"formatters":{"name":"formatters","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core_internal.FormatterMap","inner":[]}],"value":"null","annotations":[]},"_exceptionHandler":{"name":"_exceptionHandler","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core.ExceptionHandler","inner":[]}],"value":"null","annotations":[]},"_ttl":{"name":"_ttl","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core.ScopeDigestTTL","inner":[]}],"value":"null","annotations":[]},"_zone":{"name":"_zone","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core.VmTurnZone","inner":[]}],"value":"null","annotations":[]},"_scopeStats":{"name":"_scopeStats","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core.ScopeStats","inner":[]}],"value":"null","annotations":[]},"closureMap":{"name":"closureMap","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core.ClosureMap","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"operators":{},"methods":{"digest":{"name":"digest","qualifiedName":"angular-core.RootScope.digest","comment":"<p>Propagates changes between different parts of the application model. Normally called by\nVMTurnZone right before DOM rendering to initiate data binding. May also be called directly\nfor unit testing.</p>\n<p>Before each iteration of change detection, <a>angular-core.RootScope.digest</a> first processes the async queue. Any\nwork scheduled on the queue is executed before change detection. Since work scheduled on\nthe queue may generate more async calls, <a>angular-core.RootScope.digest</a> must process the queue multiple times before\nit completes. The async queue must be empty before the model is considered stable.</p>\n<p>Next, <a>angular-core.RootScope.digest</a> collects the changes that have occurred in the model. For each change,\n<a>angular-core.RootScope.digest</a> calls the associated <a>angular-core.ReactionFn</a>. Since a <a>angular-core.ReactionFn</a> may further change the model,\n<a>angular-core.RootScope.digest</a> processes changes multiple times until no more changes are detected.</p>\n<p>If the model does not stabilize within 5 iterations, an exception is thrown. See\n<a>angular-core.ScopeDigestTTL</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"flush":{"name":"flush","qualifiedName":"angular-core.RootScope.flush","comment":"","commentFrom":"angular-core.RootScope.flush","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"runAsync":{"name":"runAsync","qualifiedName":"angular-core.RootScope.runAsync","comment":"","commentFrom":"angular-core.RootScope.runAsync","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"domWrite":{"name":"domWrite","qualifiedName":"angular-core.RootScope.domWrite","comment":"","commentFrom":"angular-core.RootScope.domWrite","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"domRead":{"name":"domRead","qualifiedName":"angular-core.RootScope.domRead","comment":"","commentFrom":"angular-core.RootScope.domRead","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"fn":{"name":"fn","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"destroy":{"name":"destroy","qualifiedName":"angular-core.RootScope.destroy","comment":"","commentFrom":"angular-core.Scope.destroy","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"angular-core.RootScope.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>angular-core.RootScope.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"angular-core.RootScope.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"parentScope":{"name":"parentScope","qualifiedName":"angular-core.RootScope.parentScope","comment":"<p>The parent <a>angular-core.Scope</a>.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.parentScope","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular-core.Scope","inner":[]}],"parameters":{},"annotations":[]},"isDestroyed":{"name":"isDestroyed","qualifiedName":"angular-core.RootScope.isDestroyed","comment":"<p>Return <code>true</code> if the scope has been destroyed. Once scope is destroyed\nNo operations are allowed on it.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.isDestroyed","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isAttached":{"name":"isAttached","qualifiedName":"angular-core.RootScope.isAttached","comment":"<p>Returns true if the scope is still attached to the <a>angular-core.RootScope</a>.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.isAttached","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"hasOwnStreams":{"name":"hasOwnStreams","qualifiedName":"angular-core.RootScope.hasOwnStreams","comment":"<p>Do not use. Exposes internal state for testing.</p>","commentFrom":"","inheritedFrom":"angular-core.Scope.hasOwnStreams","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"angular-core.RootScope.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>angular-core.RootScope.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>angular-core.RootScope.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}},"methods":{"toString":{"name":"toString","qualifiedName":"angular-core.RootScope.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"angular-core.RootScope.noSuchMethod","comment":"<p><a>angular-core.RootScope.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>angular-core.RootScope.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>angular-core.RootScope.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>angular-core.RootScope.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"watch":{"name":"watch","qualifiedName":"angular-core.RootScope.watch","comment":"<p>Use <a>angular-core.RootScope.watch</a> to set up change detection on an expression.</p><ul><li>\n<p><a>angular-core.RootScope.watch.expression</a>: The expression to watch for changes.\n  Expressions may use a special notation in addition to what is supported by the parser.\n  In particular:</p></li><li>\n<p>If an expression begins with '::', it is unwatched as soon as it evaluates to a non-null\n  value.</p></li><li>\n<p>If an expression begins with ':', it only calls the <a>angular-core.RootScope.watch.reactionFn</a> if the expression\n  evaluates to a non-null value.</p></li><li>\n<p><a>angular-core.RootScope.watch.reactionFn</a>: The reaction function to execute when a change is detected in the watched\n  expression.</p></li><li>\n<p><a>angular-core.RootScope.watch.context</a>: The object against which the expression is evaluated. This defaults to the\n  <a>angular-core_internal.Scope.context</a> if no context is specified.</p></li><li>\n<p><a>angular-core.RootScope.watch.formatters</a>: If the watched expression contains formatters,\n  this map specifies the set of formatters that are used by the expression.</p></li><li>\n<p><a>angular-core.RootScope.watch.canChangeModel</a>: Specifies whether the <a>angular-core.RootScope.watch.reactionFn</a> changes the model. Reaction\n  functions that change the model are processed as part of the <a>angular-core.RootScope.digest</a> cycle. Otherwise,\n  they are processed as part of the <a>angular-core.RootScope.flush</a> cycle.</p></li><li>\n<p><a>angular-core.RootScope.watch.collection</a>: If <code>true</code>, then the expression points to a collection (a list or a map),\n  and the collection should be shallow watched. If <code>false</code> then the expression is watched\n  by reference. When watching a collection, the reaction function receives a\n  <a>change_detection.CollectionChangeItem</a> that lists all the changes.</p></li></ul>","commentFrom":"","inheritedFrom":"angular-core.Scope.watch","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular-core.Watch","inner":[]}],"parameters":{"expression":{"name":"expression","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"reactionFn":{"name":"reactionFn","optional":false,"named":false,"default":false,"type":[{"outer":"angular-core.ReactionFn","inner":[]}],"value":"null","annotations":[]},"context":{"name":"context","optional":true,"named":true,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"formatters":{"name":"formatters","optional":true,"named":true,"default":false,"type":[{"outer":"angular-core_internal.FormatterMap","inner":[]}],"value":"null","annotations":[]},"canChangeModel":{"name":"canChangeModel","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]},"collection":{"name":"collection","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"eval":{"name":"eval","qualifiedName":"angular-core.RootScope.eval","comment":"","commentFrom":"","inheritedFrom":"angular-core.Scope.eval","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"expression":{"name":"expression","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"locals":{"name":"locals","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"apply":{"name":"apply","qualifiedName":"angular-core.RootScope.apply","comment":"","commentFrom":"","inheritedFrom":"angular-core.Scope.apply","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"expression":{"name":"expression","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"locals":{"name":"locals","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"emit":{"name":"emit","qualifiedName":"angular-core.RootScope.emit","comment":"","commentFrom":"","inheritedFrom":"angular-core.Scope.emit","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular-core.ScopeEvent","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"data":{"name":"data","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"broadcast":{"name":"broadcast","qualifiedName":"angular-core.RootScope.broadcast","comment":"","commentFrom":"","inheritedFrom":"angular-core.Scope.broadcast","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular-core.ScopeEvent","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]},"data":{"name":"data","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"on":{"name":"on","qualifiedName":"angular-core.RootScope.on","comment":"","commentFrom":"","inheritedFrom":"angular-core.Scope.on","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular-core_internal.ScopeStream","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"createChild":{"name":"createChild","qualifiedName":"angular-core.RootScope.createChild","comment":"","commentFrom":"","inheritedFrom":"angular-core.Scope.createChild","static":false,"abstract":false,"constant":false,"return":[{"outer":"angular-core.Scope","inner":[]}],"parameters":{"childContext":{"name":"childContext","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"destroy":{"name":"destroy","qualifiedName":"angular-core.RootScope.destroy","comment":"","commentFrom":"","inheritedFrom":"angular-core.Scope.destroy","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[{"name":"angular-core-annotation_src.Injectable","parameters":[]}],"generics":{}}